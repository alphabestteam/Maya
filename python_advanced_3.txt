Decorators:
1. a. As it sounds, decorators decorate the function. It is a function that you put above a function, and the outer function that adds some functionality to the inner function is called a decorator. There are more types of decorators such as @property decorator that you put above a getter function in a class, or other built-in decorators. We need decorators in order for the code to be more efficient (because it can be a less complicated with decorators), and the code is not repetitive. also we can add the decorator without changing anything in the function, the decorator fits itself to the function
b. When you write a decorator for a function, in python the decorator function basically adds up to the function it decorates. So for example if you write a decoration like that:
@decoration
def func():
	print(“hello world”)
it’s the same as writing that for python:
func = decorator(func)
c. pointer function is a variable for the memory address of a function. in python because it’s high level and does not have access to the memory, it doesn’t have an actual memory address for a function. however python is a very flexible language and has other solution to work with functions as objects. You can return a function from a function or put a function as a variable and more which means that you don’t need pointer function.
d. we need to use *args and **kwargs when creating a decorator because the whole point of a decorator is that it’s a function that can be fit in into an inner function. so it needs to work always for all input the inner function needs, and *args and **kwargs are the most general ways of getting inputs.
e. an example is @propery that we use for a getter function in a class. 

Iterators:
2. a. an iterator is an object that has a specific number of values inside of it (like list, tuples, and dictionaries).
b. List, tuple, and dictionary
c. When you use the del function, it deletes an object from the memory, to free space in the memory. It removes all references to the object and everything that relates to it
d. To turn an object be an iterator, we need to use the __iter___ function which turns an object to be an iterator so you can run on the object and the function __next__ in order to point on the next index in the object and stop when there is no next (kind of like a for loop).
Generators:
3. a. generators are special functions that do not return a value but use the keyword yield, which is like return but a bit different. After using yield, the function returns a value but the function continues from the line after the yield and continues from there. So basically yield returns values from different parts of the function, these values are iterators.
b. we will want to use generators because it saves up memory and because you can return many values from different parts of the function which is very useful and necessary for different needs.
c. we can save a generator function as a variable and so the variable because of that will be an iterator. So for example if we want to run different parts of the function on different parts of our code, we can do that by saving as a variable and running on it.
d. yield is different from return because yield returns values from different parts of the function (when we call the yield keyword it returns a value and then continues running on the function from the point it stopped), and when we use the return keyword, it returns a value but does not go back to the function.
